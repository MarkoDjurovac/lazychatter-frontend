<script lang="ts">
  import MessageBubble from '$lib/components/message.svelte';
  import Toast from '$lib/components/toast.svelte';
  import { createEventDispatcher } from 'svelte';
  import { onMount, onDestroy, afterUpdate } from 'svelte';
  import { Utils } from '$lib/utilities';
  import { sendMessage, getMessagesByChatId} from '../../services/message';
  import type { Message, Chat, User } from '../types';
  import closeIcon from '$lib/assets/close.svg';
  import sendIcon from '$lib/assets/send.svg';

 /*
  * Dispatches events to the parent component.
  * @function
  */
  const dispatch = createEventDispatcher();

    /*
     * The chat that is currently open.
     * @type {Chat}
     */
    export let chat: Chat;

    /*
     * The user that is currently logged in.
     * @type {User}
     */
    export let user: User;

    /*
     * The message that the user wants to send.
     * @type {string}
     */
    let messageText: string = '';

    /*
     * The messages that are currently in the chat.
     * @type {Message[]}
     */
    let messages: Message[] = [];

    /*
     * A timer that is used to detect a long press.
     * @type {any}
     */
    let pressTimer: any;

    /*
     * Indicates whether the user wants to send an AI message.
     * @type {boolean}
     */
    let showPopover = false;

    /*
     * Contains the interval that is used to poll for new messages.
     * @type {any}
     */
    let pollingInterval: any;

   /*
    * Indicates whether the message toast is visible.
    * @type {boolean}
    */
    let isToastVisible: boolean = false;

    /*
    * The message to show in the toast.
    * @type {string}
    */
    let toastMessage: string = '';

    /*
    * The type of toast to show.
    * @type {string}
    */
    let toastType: string = '';

     /*
     * Polls the messages for the chat when the component is mounted.
     * @function
     */
    onMount(async () => {
      try {
        messages = await getMessagesByChatId(chat.chatId);
        pollingInterval = setInterval(async () => {
          messages = await getMessagesByChatId(chat.chatId);
        }, 1000);
      } catch (error) {
        showToast('Error while getting messages', 'error');
      }

      const container: any = document.querySelector('.messages-container');
      container.scrollTop = container.scrollHeight;
    });

    /*
     * Clears the polling interval when the component is destroyed.
     * @function
     */
    onDestroy(() => {
      clearInterval(pollingInterval);
    });

    /*
     * Watches for changes in the chat prop.
     */
    $: {
      if (chat) {
        getMessages();
      }
    }

    /*
     * Gets the messages for the chat.
     * @async
     */
    async function getMessages() {
      try {
        messages = await getMessagesByChatId(chat.chatId);
      }
      catch(error: any) {
        showToast('Error while getting messages', 'error');
      }
    }

   /*
    * Sends a new message to the chat.
    * @param event The event that triggered the function call.
    * @async
    */
    async function sendNewMessage() {
      if(showPopover) {
        return;
      }

      let message: Message = {
        id: null,
        sender: user.username,
        messageText: messageText,
        chatID: chat.chatId,
        aiOptions: null,
      }

      try {
        await sendMessage(message);
        messages = await getMessagesByChatId(chat.chatId);
      }
      catch(error: any) {
        showToast('Error while sending message', 'error');
      }
      
      messageText = '';
    }
    
    /*
     * Sends a message to the chat that is generated by an AI.
     * @param aiOption The AI that the user selected.
    */
    async function handleAiChat(aiOption: string) {
      let message: Message = {
        id: null,
        sender: user.username,
        messageText: "",
        chatID: chat.chatId,
        aiOptions: aiOption
      };

      try {
        await sendMessage(message);
        messages = await getMessagesByChatId(chat.chatId);
      }
      catch(error: any) {
        showToast('Error while sending message', 'error');
      }
      
      showPopover = false;
    }

    /*
     * Closes the chat.
     * @function
     */
    function handleCloseChat() {
      dispatch('closechat');
    }
    
    /*
     * Handles the mousedown event.
     * @function
     */
    function handleMousedown() {
      pressTimer = setTimeout(() => showPopover = true, 1000);
    }

    /*
     * Handles the mouseup event.
     * @function
     */
    function handleMouseup() {
      clearTimeout(pressTimer);
    }

    /*
    * Handles the mouseleave event.
    * @function
    * @async
    */
    async function handleEditedOrDeletedMessage() {
      try {
        messages = await getMessagesByChatId(chat.chatId);
      } catch (error: any) {
        showToast('Error while editing or deleting message', 'error');
      }
    }
    
   /*
    * Shows a toast message.
    * @param {string} message - The message to show.
    * @param {string} type - The type of toast to show.
    */
    function showToast(message: string, type: string) {
        toastMessage = message;
        toastType = type;
        isToastVisible = true;

        setTimeout(() => {
            isToastVisible = false;
        }, 3000);
    }

    /*
     * Handles the keypress event for sending a message via the enter key.
     * @param event The event that triggered the function call.
     */
    function handleKeyPress(event: KeyboardEvent) {
      if(event.key === 'Enter' && !event.shiftKey) {
        sendNewMessage();
      }
    }
</script>

{#if isToastVisible}
    <Toast message={toastMessage} type={toastType}/>
{/if}
<div class="flex flex-col h-full bg-white space-y-4 justify-between">
  <div class="flex items-center bg-slate-200 p-1 justify-between">
    <b class="ml-4">Chat with {Utils.getParticipants(chat.paritcipants)}</b>
    <div class="flex-grow"></div>
    <button on:click={handleCloseChat} class="hover:bg-slate-200 text-black font-bold py-2 px-4 rounded transition duration-500 ease-in-out ml-2">
      <img src={closeIcon} alt="Close chat" class="w-8 h-8"/>
    </button>
  </div>
  <div class="messages-container overflow-y-scroll flex-grow flex flex-col">
    {#each messages as message}
      <MessageBubble user={user} message={message} on:edited={handleEditedOrDeletedMessage} on:deleted={handleEditedOrDeletedMessage}/>
    {/each}
  </div>
  <div class="flex items-center bg-slate-200 p-1 relative">
    <input type="text" bind:value={messageText} class="flex-grow py-2 px-4 bg-gray-50 rounded pr-10" on:keypress={handleKeyPress}/> 
    <button 
      on:click={sendNewMessage}
      on:mousedown={handleMousedown} 
      on:mouseup={handleMouseup} 
      on:mouseleave={handleMouseup}
      class="absolute right-2 bottom-2">
      <img src={sendIcon} alt="Send message" class="w-8">
    </button>
    {#if showPopover}
      <div class="absolute bottom-10 right-0 bg-white border border-gray-300 rounded shadow-lg p-2">
        <button class="block w-full text-left px-4 py-2 hover:bg-gray-200" on:click|preventDefault={() => handleAiChat("GPT")}>I'm lazy</button>
        <button class="block w-full text-left px-4 py-2 hover:bg-gray-200" on:click|preventDefault={() => handleAiChat("INSULT")}>I'm angry</button>
        <button class="block w-full text-left px-4 py-2 hover:bg-gray-200" on:click|preventDefault={() => handleAiChat("COMPLIMENT")}>I'm nice</button>
      </div>
    {/if}
  </div>
</div>